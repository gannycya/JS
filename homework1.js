//console.log('number' + 3 + 3); //number33 - так як number' тип даних строка,то + це не додавання, а 'зліплення' конкатенація
                            
//console.log(null + 3);  // 3 - бо null=0, а  + це арифметичний плюс (null + 3 → 0 + 3 → 3)

//console.log(5 && "qwerty"); // qwerty, бо && - логічний оператор І, який поверта перше falsy значення 
                              // або останнє, якщо все було truthy. В нашому випадку 5=truthy, бо
                              // це number і "qwerty" = "qwerty", бо стрінга з текстом в середині. тому
                              // повертає останнє значення

//console.log(+'40' + +'2' + "hillel"); //42hillel, бо унарний + перетворює 40 зі стрінги на число
                                      // так само 2 - вже число
                                      // 40 та 2 плюсуємо, бо була б конкатенація лише у випадку, якщо стрінга
                                      //стояла на початку, тому отримуємо 42, а далі + це конкатенація, зліплення числа і рядка

//console.log('10' - 5 === 6); // false, бо при відніманні буде стрінга приводитись до числа, тобто 10-5=5,  а 5не дорівнює 6 (по вмісту, але по типу вони рівні)

//console.log(true + false); // 1, бо немає строки, значить не буде конкатенаці. якщо немає конкатенації, то приводимо інші типи даних в 
                             // намбер, відповідно true =1, false=0, 1+0=1

//console.log('4px' - 3); //NaN - тут строку '4px' неможливо коректно перетворити на число, тому '4px' = NaN
                          // якщо від  NaN -3 = NaN

//console.log('4' - 3); //1, бо '4' строка перетворюється на число, і тоді 4-3=1

//console.log('6' + 3 ** 0); //61 , бо спершу пріоритет має піднесення до ступеня 3**0=1, а потім
                             // йде канкотенація
                            
//console.log(12 / '6'); //2, бо при діленні строка перетворюється на намбер 

//console.log('10' + (5 === 6)); // 5===6 ->false; строка + false = 10false (конкатенація)

//console.log(null == ''); // false, бо єдине виключення для null=undefined (підглянула-не пам'ятала)

//console.log(3 ** (9 / 3)); // 27, бо спершу дія  вдужках 9/3=3, а потім піднесення в степішь 3**3=27

//console.log(!!'false' == !!'true'); //true, тут я неправильно виирішила, але вже розібралась:
                                    // 'false' це непорожня строка (truthy), тому true
                                    // 'true' це непорожня строка (truthy), тому true
                                    // true==true -> true

//console.log(0 || '0' && 1); //1, бо спершу виконуємо логічне І (повертає перше false значення, або
                            // останнє,якщо все true). в нашому випадку '0'=true 1=true -> 1,
                            // 0 || 1 - маємо повернути перше true значення, тому 1    
                            
 //console.log((+null == false) < 1); //false, бо спершу дія  в дужках +null -> 0 (перевели в 
                                    // число null через унарний +). потім порівнємо не строгою рівнстю
                                    // 0==false -> true; і останнє true < 1 = 1<1 -> false                           
//console.log(false && true || true); // true  , бо спершу виконуємо логічне І (маємо повернути перше false
                                    // значення) false && true -> false
                                    // далі АБО (перше true значення) false || true -> tru

//console.log(false && (false || true)); // false, бо перша дія виконується в дужках з вибором першого true значення false||true -> true
                                       // далі дія - догічне І (перше false значення  false && true -> false)

//console.log((+null == false) < 1 ** 5); // false ,бо спершу дія  вдужках +null == false -> 0 == false -> true
                                        // далі зведення до ступеня 1**5 = 1
                                        // порівняння true < 1 -> 1<1 -> false








